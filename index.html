<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-90P9PHYQ9J"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-90P9PHYQ9J');
    </script>
    <meta charset="UTF-8" />
    <title>JSONGrapher</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.1/math.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.14.0.min.js"></script>
    <!--  We use AJV for json validation. We use the 6.12.6 version because the later version had a compilation error. To reduce the external dependency, we have the source code on our github in he AJV folder, it is an under an MIT LICENSE, as noted in the LICENSE file of JSON Grapher.
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/6.12.6/ajv.bundle.min.js" integrity="sha512-Xl0g/DHU98OkfXTsDfAAuTswzkniYQWPwLyGXzcpgDxCeH52eePfaHj/ictLAv2GvlPX2qZ6YV+3oDsw17L9qw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> -->
    <script src="./utils/AJV//6.12.6/ajv.bundle.min.js"></script>
    <link rel="stylesheet" href="./other_html/styles.css" />
    <script src="./utils/UUC/app/convert.js"></script>
    <script src="./utils/UUC/app/convert_parse.js"></script>
    <script src="./utils/UUC/app/convert_macro.js"></script>
    <script src="./utils/UUC/app/data.js"></script>
    <!-- Load the layout styles here so that the other utils can use them -->
    <script src="./styles/layout_styles_library.js"></script>
    <script src="./styles/trace_styles_collection_library.js"></script>
    <script type="module"> 
      import { copyJson } from './utils/styleUtils.js'; 
      import { parsePlotStyle } from './utils/styleUtils.js'; 
      import { applyPlotStyleToPlotlyDict } from './utils/styleUtils.js'; 
      import { cleanJsonFigDict } from './utils/figDictUtils.js'; 
      import {executeImplicitDataSeriesOperations} from './utils/json_equationer/implicitUtils.js'
    </script>  
    <style>
      .file-actions {
        display: flex;
        gap: 8px;
      }
      .file-actions #downloadButtonsContainer {
        display: flex;
        gap: 4px;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="container">
        <a href="index.html">
          <div class="button active">
            <p>JSONGrapher</p>
          </div>
        </a>
        <a href="Manual.pdf" target="_blank">
          <div class="button">
            <p>Manual</p>
          </div>
        </a>
        <a href="https://github.com/AdityaSavara/JSONGrapher" target="_blank">
          <div class="button">
            <p>Source</p>
          </div>
        </a>
        <a href="./other_html/license.html">
          <div class="button">
            <p>License</p>
          </div>
        </a>
        <a href="./other_html/credits.html">
          <div class="button">
            <p>Credits</p>
          </div>
        </a>
      </div>
    </header>
    <div class="page">
    <h1>JSONGrapher</h1>
    <p>
    JSONGrapher plots data from one or more files directly in your browser, creating interactive graphs to compare data!        
    </p>
    <div id="toggleSection">
    <p>Try plotting one of the 
        <a href="https://github.com/AdityaSavara/JSONGrapherExamples/raw/main/DemonstrationFiles.zip" target="_blank">example files</a> 
        (first unzip, then plot with JSONGrapher). Just drag-and-drop an example file into the box below, or use the browse-to-upload option. Then, add more files to compare more data on the same graph!
    </p>
        To make your own files, use the <a href="https://github.com/AdityaSavara/jsongrapher-py" target="_blank">python JSONGrapher</a>,
        or the <a href="https://adityasavara.github.io/JSONGrapher/other_html/BrowserRecordCreator/BrowserRecordCreator.html" target="_blank"> browser record creator</a>,
        or see the <a href="https://adityasavara.github.io/JSONGrapher/Manual.pdf" target="_blank">manual</a>.<br>

    <a href="https://www.dropbox.com/s/1s8ib1rsv3xmj1c/3_edited.mp4?dl=0" target="_blank">How to Plot and Features Video</a> | 
    <a href="https://adityasavara.github.io/JSONGrapher/Manual.pdf" target="_blank">Manual</a> |
    <a href="https://github.com/AdityaSavara/JSONGrapherExamples/raw/main/DemonstrationFiles.zip" target="_blank">Example Files</a> | 
    <a href="https://github.com/AdityaSavara/JSONGrapherExamples/" target="_blank">More Examples</a>
    </div>

    
    <div id="toReveal" style="display: none;""><a href="https://www.dropbox.com/s/1s8ib1rsv3xmj1c/3_edited.mp4?dl=0" target="_blank">How to Plot and Features Video</a> | 
    <a href="https://adityasavara.github.io/JSONGrapher/Manual.pdf" target="_blank">Manual</a> |
    <a href="https://github.com/AdityaSavara/JSONGrapherExamples/raw/main/DemonstrationFiles.zip" target="_blank">Example Files</a> (Files must be unzipped to plot) | 
    <a href="https://github.com/AdityaSavara/JSONGrapherExamples/" target="_blank">More Examples</a> |
    </div>
</p>

      <div class="file-actions">
        <input type="file" id="file-selector" />
        <button id="reset" onclick="clearData()">Clear Data</button>
        <button id="load-from-url">From URL</button>        
        <button id="download" style="display: none">
          Download Last Data Set as a JSON File
        </button>
        <div id="downloadButtonsContainer"></div>
      </div>
      <p></p>
      <div id="file-drop-area">
        Drop a file here:
        <pre></pre>
      </div>
      <div id="plotlyDiv">
        <!-- Plotly chart will be drawn inside this DIV -->
      </div>
      <div id="errorDiv"></div>
      <div id="downloadLink"></div>
      <div id="copyUrlLink"></div>
      <div id="conceptDiv">
        <!-- The concept image will be shown in this div. -->
        <pre></pre>
        <center><img src="./other_html/ConceptImage.png" width="600" /></center>
      </div>
    </div>
    <script>
      //JSONGrapher has the following steps, which will be commented in the MAIN BLOCK OF CODE of JSONGrapher:
      // STEP 0: Prepare the 'universal' schemas
      // STEP 1: User selects a file from computer or drops a file on the browser
      // STEP 2: If the file is a .csv or .tsv file it is converted to a .json file
      // STEP 3: Check if the jsonified object is a valid JSON file against the schema
      // STEP 4: Check if the object has a dataSet that has a simulate key in it, and runs the simulate function
      // STEP 5: Check if the units in the dataset are the same as the units in the previous object and convert them
      // STEP 6: Provide file with converted units for download as JSON and CSV by buttons
      // STEP 7: The plotly template is rendered on the browser


      // Global Variables
      let globalData = null;
      let plotlyTemplate = null;
      let schema = null;
      let recentFileName = null;
      let schemaURL = "";
      let schemaTemplateURL = "";
      let url = window.location.href; // Get the current page URL         
      let params = new URLSearchParams(new URL(url).search);
      let urlParamsString = params.get("fromUrl"); //default ends up as null.
      let urlReceived = "" //Start as an empty string. Will populate this later from the user's input or from the urlParamsString


      // Initializing the AJV validator
      const ajv = new Ajv();
      const errorDiv = document.getElementById("errorDiv");
      // Initiating the UUC converter
      const convert = new Convert();

      // A function that clears the data from global variables and removes the error text and plotly chart
      function clearData() {
        globalData = null;
        urlParamsString = null; //empty this global variable.
        urlReceived = null; //empty this global variable.
        document.getElementById("errorDiv").innerHTML = "";
        document.getElementById("downloadButtonsContainer").innerHTML = "";
        document.getElementById("file-selector").value = "";
        document.getElementById("load-from-url").value = "";
        document.getElementById("download").style.display = "none";
        const toggleSection = document.getElementById("toggleSection"); //Now will reveal again.
        const toRevealSection = document.getElementById("toReveal");   // Now will hide.
        toggleSection.style.display = "block"; // "none" to hide and "block" to show. Those are built in keywords.
        toRevealSection.style.display = "none"; // "none" to hide and "block" to show. Those are built in keywords.
        Plotly.purge("plotlyDiv");
      }

      // A function that checks if the uploaded file extension
      function findFileType(fileName) {
        let arrayName = fileName.split(".");
        if (arrayName.includes("csv")) {
          return "csv";
        }
        if (arrayName.includes("tsv")) {
          return "tsv";
        }
        return "json";
      }

      //function to retrieve JSON Record from url
      async function loadJsonFromUrl(url) { 
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error("Network response was not OK");
          const jsonData = await response.json();
          return jsonData;
        } catch (error) {
          console.error("Error fetching JSON:", error);
          return null;
        }
      }

      // A function the jsonifies a tsv file
      function jsonifyTSV(fileContent) {
        //separate rows
        let arr = fileContent.split("\n");

        //if last row is empty remove it
        if (arr[arr.length - 1].length < 2) {
          arr = arr.slice(0, arr.length - 1);
        }

        //count number of columns
        let number_of_columns = arr[0].split("\t").length;

        //extract the config information
        let comments = arr[0].split("\t")[0].split(":")[1].trim();
        let data_type = arr[1].split("\t")[0].split(":")[1].trim();
        let chart_label = arr[2].split("\t")[0].split(":")[1].trim();
        let x_label = arr[3].split("\t")[0].split(":")[1].trim();
        let y_label = arr[4].split("\t")[0].split(":")[1].trim();
        custom = arr[5]; //This field is for custom json objects and is currently ignored.

        //extract the series names
        let series_names_array = arr[5]
          .split(":")[1]
          .split('"')[0]
          .split("\t")
          .map((n) => n.trim());

        //ignore arr[7] which is custom_variables:

        //extract the data
        let data = arr
          .slice(8)
          .map((r) => r.split("\t").map((str) => Number(str)));

        let resultJSON = JSON.parse(JSON.stringify(plotlyTemplate, null, 2)); // clone of the template. The ", null, 2" is optional to make the json more human readable.

        resultJSON.comments = comments;
        resultJSON.datatype = data_type;
        resultJSON.layout.title = { text: chart_label };
        resultJSON.layout.xaxis.title = { text: x_label };
        resultJSON.layout.yaxis.title = { text: y_label };

        let newData = [];
        series_names_array.forEach((series_name, index) => {
          let dataClone = JSON.parse(
            JSON.stringify(plotlyTemplate.data[0], null, 2)
          ); // the ", null, 2" is optional to make the json more human readable.
          dataClone.name = series_name;
          dataClone.x = data.map((r) => r[0]);
          dataClone.y = data.map((r) => r[index + 1]);
          dataClone.uid = dataClone.uid + String(index);
          newData.push(dataClone);
        });

        resultJSON.data = newData;

        return resultJSON;
      }

      // A function the jsonifies a csv file
      function jsonifyCSV(fileContent) {
        //separate rows
        let arr = fileContent.split("\n");
        //if last row is empty remove it
        if (arr[arr.length - 1].length < 2) {
          arr = arr.slice(0, arr.length - 1);
        }

        //count number of columns
        let number_of_columns = arr[5].split(",").length;

        //extract the config information
        let comments = arr[0].split(",")[0].split(":")[1].trim();
        let data_type = arr[1].split(",")[0].split(":")[1].trim();
        let chart_label = arr[2].split(",")[0].split(":")[1].trim();
        let x_label = arr[3].split(",")[0].split(":")[1].trim();
        let y_label = arr[4].split(",")[0].split(":")[1].trim();

        //extract the series names
        let series_names_array = arr[5]
          .split(":")[1]
          .split('"')[0]
          .split(",")
          .map((n) => n.trim());

        //extract the data
        let data = arr
          .slice(7)
          .map((r) => r.split(",").map((str) => Number(str)));

        let resultJSON = JSON.parse(JSON.stringify(plotlyTemplate, null, 2)); // clone of the template. The "null, 2" are optional arguments that increase human readability.

        resultJSON.comments = comments;
        resultJSON.datatype = data_type;
        resultJSON.layout.title = { text: chart_label };
        resultJSON.layout.xaxis.title = { text: x_label };
        resultJSON.layout.yaxis.title = { text: y_label };

        //Remove any series where the series name is blank.
        function isNotBlank(value) {
          return value != "";
        }
        series_names_array = series_names_array.filter(isNotBlank);

        //We make a data set for each series_name, this way the blank series_name that have been removed will not be included.
        let newData = [];
        series_names_array.forEach((series_name, index) => {
          let dataClone = JSON.parse(
            JSON.stringify(plotlyTemplate.data[0]),
            null,
            2
          ); // the ", null, 2" are optional arguments to increase human readability.
          dataClone.name = series_name;
          dataClone.x = data.map((r) => r[0]);
          dataClone.y = data.map((r) => r[index + 1]);
          dataClone.uid = dataClone.uid + String(index);
          newData.push(dataClone);
        });

        resultJSON.data = newData;
        return resultJSON;
      }

      // Gets the name of the uploaded file
      function getFileName(fileName) {
        let arrayName = fileName.split(".");
        return arrayName[0];
      }

      // A function checks the extension of the file and calls the appropriate function to jsonfiy the file
      function jsonifyData(filetype, dataLoaded) {
        switch (filetype) {
          case "csv": {
            return jsonifyCSV(dataLoaded);
          }
          case "tsv": {
            return jsonifyTSV(dataLoaded);
          }
          default: {
            return JSON.parse(dataLoaded);
          }
        }
      }

      function isValidUrl(urlString) {
        var urlPattern = new RegExp(
          "^(https?:\\/\\/)?" + // validate protocol
            "((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|" + // validate domain name
            "((\\d{1,3}\\.){3}\\d{1,3}))" + // validate OR ip (v4) address
            "(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*" + // validate port and path
            "(\\?[;&a-z\\d%_.~+=-]*)?" + // validate query string
            "(\\#[-a-z\\d_]*)?$",
          "i"
        ); // validate fragment locator
        return !!urlPattern.test(urlString);
      }
      
      // function to extract from the datatype the location of the schema
      function getSchemaLocation(jsonified, template = false) {
        if (!jsonified.datatype) {
          errorDiv.innerText += "Warning: The datatype field was not found in the record provided. Accordingly, a schema check will not be performed and the record will not be fully validated. \n";
          jsonified.datatype = ""; // Populate with an empty string
        }

        if (isValidUrl(jsonified.datatype)) {
          const template_suffix = jsonified.datatype.replace(
            ".schema.json",
            ".schema.template.json"
          );
          return !template ? jsonified.datatype : template_suffix;
        } else if (jsonified.datatype.endsWith("schema.json")) {
          if (template) {
            const template_suffix = jsonified.datatype.replace(
              ".schema.json",
              ".schema.template.json"
            );
            return "./utils/schema/" + template_suffix;
          } else {
            return "./utils/schema/" + jsonified.datatype;
          }
        } else {
          if (template) {
            return "./utils/schema/" + jsonified.datatype + ".schema.template.json";
          } else {
            return "./utils/schema/" + jsonified.datatype + ".schema.json";
          }
        }
      }

      // function to extract from the datatype the json schema
      async function getSchemaType(jsonified) {
        let schema2body;
        schema_location = getSchemaLocation(jsonified);
        const schema_template_location = getSchemaLocation(jsonified, true);
        try {
          const schema1 = await fetch(schema_location);
          const schema2 = await fetch(schema_template_location);
          const schema1body = await schema1.text();
          if (schema2.status == 404) {
            schema2body = "{}";
          } else {
            schema2body = await schema2.text();
          }
          const schema1json = JSON.parse(schema1body);
          const schema2json = JSON.parse(schema2body);
          return [schema1json, schema2json];
        } catch (err) {
          // TODO: !! error catching to be made informative.
          //errorDiv.innerText += "undocumented error in getSchemaType\n";

          try {
            const schema1 = await fetch("./utils/schema/0_PlotlyTemplate.json");
            const schema1body = await schema1.text();
            const schema1json = JSON.parse(schema1body);
            return [schema1json, {}];
          } catch (err2) {
            return [{}, {}];
          }
          return [{}, {}];
        }
      }

      // A function that prepares the plotly schema and the template for the jsonification
      async function prepareUniversalSchemas() {
        const schema1 = await fetch("./utils/schema/plot-schema.json");
        const schema1body = await schema1.text();
        const schema1json = JSON.parse(schema1body);
        const schema2 = await fetch("./utils/schema/0_PlotlyTemplate.json");
        const schema2body = await schema2.text();
        const schema2json = await JSON.parse(schema2body);
        return [schema1json, schema2json];
      }

      // A function that gets the unit from the label with regex
      function getUnitFromLabel(label) {
        if (!label) {
          console.warn("Label is undefined or null");
          return "";
        }
        let unit = label.match(/\((.*)\)/);
        if (unit) {
          return unit[1].replace(/\*\*/g, "^");//The replace in here replaces ** with ^, to replace python style "raise to the power of" with the conventional symbol.
        }
        return "";
      }

      //This is a helper function to create superscript tags for plotly right before plotting.
      function replaceSuperscripts(inputString) {
        // Step 1: Wrap superscript expressions in <sup> tags
        let outputString = inputString.replace(/\^\((.*?)\)|\*\*\((.*?)\)/g, 
          (match, p1, p2) => `<sup>${p1 || p2}</sup>`);

        // Step 2: Remove parentheses if the content is only digits
        outputString = outputString.replace(/<sup>\((\d+)\)<\/sup>/g, '<sup>$1</sup>');

        // Step 3: Remove parentheses if the content is a negative number (- followed by digits)
        outputString = outputString.replace(/<sup>\(-(\d+)\)<\/sup>/g, '<sup>-$1</sup>');

        // Step 4: Remove parentheses if the superscript is a single letter
        outputString = outputString.replace(/<sup>\((\w)\)<\/sup>/g, '<sup>$1</sup>');

        return outputString;
      }

      // A function that removes the unit from the label
      function removeUnitFromLabel(label) {
        const unit = getUnitFromLabel(label);
        return label.replace(/\*\*/g, "^").replace(unit, "").replace("()", ""); //need to first replace ** with ^ to be prepared for that part of getUnitFromLabel's processing.
      }

      // Checking if the dataSet has simulation
      function checkSimulate(dataSet) {
        if (dataSet.simulate) {
          return true;
        }
        return false;
      }

      // Get raw content of github file from url
      async function getRawContent(url) {
        return new Promise(async (resolve, reject) => {
          try {
            const res = await fetch(url);
            const data = await res.text();
            resolve(data);
          } catch (err) {
            reject(err);
          }
        });
      }

      // Changes the Github link to a CDN link to avoid CORB issues
      // TODO: currently we only support javascript from github. In the future, cross-domain / cross-origin simulate functions will be supported by SRI hash. https://www.w3schools.com/Tags/att_script_crossorigin.asp https://www.w3schools.com/Tags/att_script_integrity.asp with the SRI hash provided within the simulate object by a field in the JSON record named "SRI" or 'integrity"
      function parseUrl(url) {
        const urlArr = url.split("/");
        if (urlArr[2] === "github.com") {
          return url
            .replace("github.com", "raw.githubusercontent.com")
            .replace("/blob/", "/")
            .replace("/tree/", "/")
            .replace("www.", "");
        } else {
          return url;
        }
      }

      //  a function that gets the simulate script from an external file by url
      /**
       * A function that gets the simulate script from an external file by URL,
       * runs the simulate function, and resolves the output.
       */
      async function getAndRunSimulateScript(dataSet, jsonified, index) {
          return new Promise(async (resolve, reject) => {
        try {
            // Create a script element
            const loadScript = document.createElement("script");

            // Debug the URL being parsed and fetched
            const scriptUrl = parseUrl(dataSet.simulate.model);

            // Get the raw content from the specified URL
            const data = await getRawContent(scriptUrl);

            // Attach the content to the script element
            loadScript.textContent = data;

            // Add the script to the document head
            document.getElementsByTagName("head")[0].appendChild(loadScript);

            // Debug if simulate function is available globally
            if (typeof simulate !== "function") {
                console.error("Error: simulate function is not defined!");
                throw new Error("simulate function is not defined");
            }

            // Execute the simulate function with the dataset
            const simulatedData = await simulate(dataSet);

            // Check if simulatedData is an array
            if (Array.isArray(simulatedData)) {
                // Log an error message for arrays
                console.log("Simulate function failed, simulate function log:", JSON.stringify(simulatedData));
            } else {
                //Uncomment to Log the simulated data for non-array JSON types
                //console.log("Simulated Data:", JSON.stringify(simulatedData));
            }            

            // Resolve the Promise with the simulated data
            resolve(simulatedData);
        } catch (err) {
            // Log the error details
            console.error("Error occurred in getAndRunSimulateScript:", err);
            reject({ status: "error", error: "Error: " + err });
        }

        });
      }
     
      // Check the units of the simulated data compared to the json record layout field and convert them if needed
      function maybeConvertSimulatedDataUnits(jsonified, simulatedData, index) {
        return new Promise((resolve, reject) => {
          try {
            // Javascript doesn't have deep clones so we use the JSON solution
            // source: https://stackoverflow.com/questions/597588/how-do-you-clone-an-array-of-objects-in-javascript
            let _simulatedData = JSON.parse(JSON.stringify(simulatedData));
            const desiredXUnit = getUnitFromLabel(jsonified.layout.xaxis.title.text);
            const desiredYUnit = getUnitFromLabel(jsonified.layout.yaxis.title.text);
            const simulatedXUnit = getUnitFromLabel(simulatedData.data.x_label);
            const simulatedYUnit = getUnitFromLabel(simulatedData.data.y_label);

            if (desiredXUnit !== simulatedXUnit) {
              const xConvertFactor = convert.fullConversion(
                simulatedXUnit,
                desiredXUnit
              );
              const convertedXArray = _simulatedData.data.x.map((x) => {
                if (xConvertFactor.status == 0) {
                  return parseFloat(x) * xConvertFactor.output.num;
                } else {
                  xConvertFactor.messages.forEach((message) => {
                    errorDiv.innerText += message.message + "\n";
                  });
                }
              });
              _simulatedData.data.x = convertedXArray;
              _simulatedData.data.x_label =
                removeUnitFromLabel(_simulatedData.data.x_label) +
                "(" +
                desiredXUnit +
                ")";
            }

            if (desiredYUnit !== simulatedYUnit) {
              const yConvertFactor = convert.fullConversion(
                simulatedYUnit,
                desiredYUnit
              );
              const convertedYArray = _simulatedData.data.y.map((y) => {
                if (yConvertFactor.status == 0) {
                  return parseFloat(y) * yConvertFactor.output.num;
                } else {
                  yConvertFactor.messages.forEach((message) => {
                    errorDiv.innerText += message.message + "\n";
                  });
                }
              });
              _simulatedData.data.y = convertedYArray;
              _simulatedData.data.y_label =
                removeUnitFromLabel(_simulatedData.data.y_label) +
                "(" +
                desiredYUnit +
                ")";
            }

            resolve(_simulatedData);
          } catch (err) {
            reject({ status: "error", error: "Error: " + err });
          }
        });
      }

      // Gets the simulation data and adds it to the jsonified object
      function mergeSimulationData(simulationResult, jsonified, index) {
        return new Promise((resolve, reject) => {
          try {
            if(!jsonified.layout.xaxis.title.text){ //Take the label from the simulation if there isn't one already.
              jsonified.layout.xaxis.title.text = simulationResult.data.x_label;
            }
            if(!jsonified.layout.yaxis.title.text){ //Take the label from the simulation if there isn't one already.
              jsonified.layout.yaxis.title.text = simulationResult.data.y_label;
            }
            jsonified.data[index].x = simulationResult.data.x;
            jsonified.data[index].y = simulationResult.data.y;
            resolve(jsonified);
          } catch (err) {
            reject({ status: "error", error: "Error: " + err });
          }
        });
      }

      async function simulateByIndexAndPopulateFigDict(_jsonified, index) {
        const dataSet = _jsonified.data[index]; // Retrieve dataSet using the provided index
        if (!dataSet) {
          throw new Error(`No dataSet found at index ${index}`);
        }
        const simulatedData = await getAndRunSimulateScript(dataSet, _jsonified, index);         
        const convertSimulatedDataUnits = await maybeConvertSimulatedDataUnits(_jsonified, simulatedData, index);
        // This function call populates the correct data series in _jsonified.
        const simulatedJsonified = await mergeSimulationData(convertSimulatedDataUnits, _jsonified, index); 
        return {_jsonified, simulatedJsonified}

      }

      // A function that visualizes the data with plotly
      function plot_with_plotly(figDict) {
        let plotStyle = { layout_style: "", trace_styles_collection: "" };
          if (JSON.stringify(plotStyle) === JSON.stringify({ layout_style: "", trace_styles_collection: "" })) {
              plotStyle = figDict.plot_style ?? { layout_style: "", trace_styles_collection: "" };
          }

          // Parse the plot style
          plotStyle = parsePlotStyle(plotStyle);
          // Apply the plot style
          figDict = applyPlotStyleToPlotlyDict(figDict, plotStyle);
          // Clean out the fields and make a Plotly object


          let copyForPlotly = JSON.parse(JSON.stringify(figDict)); // Plotly mutates the input
          copyForPlotly = cleanJsonFigDict(copyForPlotly, ["simulate", "custom_units_chevrons", "equation", "trace_style", "3d_axes", "bubble", "superscripts"]);          
          // Replace superscripts in some fields for Plotly
          if (copyForPlotly.layout.scene) {
            copyForPlotly.layout.scene.yaxis.title.text = replaceSuperscripts(copyForPlotly.layout.scene.yaxis.title?.text ?? "");
            copyForPlotly.layout.scene.xaxis.title.text = replaceSuperscripts(copyForPlotly.layout.scene.xaxis.title?.text ?? "");
          } else {
            copyForPlotly.layout.yaxis.title.text = replaceSuperscripts(copyForPlotly.layout.yaxis.title?.text ?? "");
            copyForPlotly.layout.xaxis.title.text = replaceSuperscripts(copyForPlotly.layout.xaxis.title?.text ?? "");
          }
          // Ensure Plotly is available before calling newPlot
          if (typeof Plotly !== "undefined") {
              Plotly.newPlot("plotlyDiv", copyForPlotly.data, copyForPlotly.layout);
          } else {
              console.error("Plotly is not loaded.");
          }
      }

      // A function that will create a csv string from the jsonified data
      // Returns Error: "The CSV could not be created: currently the CSV export only supports creating CSV files for XYYY data and not for cases that require XYXY."
      function createCSV(jsonified) {
        // Defining the variables
        let csv = "";
        let bulkValues = "";
        let errors = false;
        const csvHeadersArray = [];
        const csvValuesArray = [];
        const xLabel = jsonified.layout.xaxis.title.text;
        const yLabel = jsonified.layout.yaxis.title.text;
        const comments = jsonified.comments;
        const dataType = jsonified.datatype;
        const chartLabel = jsonified.layout.title.text;
        const dataSets = jsonified.data;
        const dataSetIndex = jsonified.data.length - 1;
        const dataSet = jsonified.data[dataSetIndex];
        let seriesName = "";

        // Adding the name of each dataset separated by comma
        dataSets.forEach((dataSet) => {
          const last =
            dataSets.indexOf(dataSet) === dataSets.length - 1 ? true : false;
          const suffix = !last ? "," : "";
          seriesName += dataSet.name + suffix;
        });

        // Concatenating the values into the string
        csv += "comments: " + comments + "\r\n";
        csv += "DataType: " + dataType + "\r\n";
        csv += "Chart_label: " + chartLabel + "\r\n";
        csv += "x_label: " + xLabel + "\r\n";
        csv += "y_label: " + yLabel + "\r\n";
        csv += "series_names: " + seriesName + "\r\n";

        csv += "x_values";

        // Iterating through the data sets and adding the x and y headers to the csv string and checking if all x arrays are equal
        dataSets.forEach((dataSet, index) => {
          const idx = `_${index + 1}`;
          const suffix = index === dataSets.length - 1 ? "\r\n" : "";
          csv += ",y" + idx + suffix;
        });
        dataSets[0].x = dataSets[0].x || []; //create the x array if it does not exist (for equation dataseries etc.)
        dataSets[0].y = dataSets[0].y || []; //create the y array if it does not exist (for equation dataseries etc.)
        dataSets[0].x.forEach((x, _index) => {
          let extraYValues = "";
          for (let i = 0; i < dataSets.length; i++) {
            extraYValues += "," + dataSets[i].y[_index];
          }
          csv += x + extraYValues + "\r\n";
        });

        for (const dataSet of dataSets) {
          const first_X_array = dataSets[0].x;
          // Checking if all the x arrays are equal
          if (dataSet.x.toString() !== first_X_array.toString()) {
            errors = true;
            csv =
              "Error: The CSV could not be created: currently the CSV export only supports creating CSV files for XYYY data and not for cases that require XYXY.";
          }
        }

        return {
          csv: csv,
          filename: chartLabel + ".csv",
        };
      }

      // A function that will create a download link for the csv file
      function createDownloadCSVLink(csv, filename) {
        if (filename===null){filename="JSONGrapherRecord.csv";};
        let csvFile;
        let downloadLink;
        // CSV file
        csvFile = new Blob([csv], { type: "text/csv" });
        // Download link
        downloadLink = document.createElement("a");
        // File name
        downloadLink.download = filename;
        // Create a link to the file
        downloadLink.href = window.URL.createObjectURL(csvFile);
        // Hide download link
        downloadLink.style.display = "none";
        return downloadLink;
      }

      // A function that will create a download link for the json file
      function createDownloadJSONLink(json, filename) {
        if (filename===null){filename="JSONGrapherRecord.json";};
        let jsonFile;
        let downloadLink;
        // JSON file
        jsonFile = new Blob([JSON.stringify(json)], {
          type: "application/json",
        });
        // Download link
        downloadLink = document.createElement("a");
        // File name
        downloadLink.download = filename;
        // Create a link to the file
        downloadLink.href = window.URL.createObjectURL(jsonFile);
        // Hide download link
        downloadLink.style.display = "none";
        return downloadLink;
      }

      // A function that will create a bz2 and encoded URL for the final graph.
      // This approach was abandoned because the URL strings were too long for both some browsers and some webservers limits.
      function jsonToUrl(json) {
          //For now, am hardcoding url, because otherwise the repository github pages url gets prefixed. The repository github pages url works, but does not look as nice.
          const prefix = `http://www.jsongrapher.com?fromUrl=`;
          //const url = window.location.href.split('?')[0]; // gets url from browser and removes query parameters
          //const prefix = `${url}?fromUrl=`;
          // Convert JSON to a string
          let jsonString = JSON.stringify(json);         
          // Concatenate with prefix and apply URL encoding, which is like the python urllib.parse.quote(json_string) and urllib.parse.unquote(encoded_string)
          let urlString = prefix + encodeURIComponent(jsonString); 
          // wanted to Compress using Bzip2, but didn't succeed in importing a JS version without problems.
          //urlString = compressjs.Bzip2.compressFile(new TextEncoder().encode(urlString));
          return urlString;
      }

      // A function that will create a URL string that allows graphing from a remote json.
      function createCopyUrlLink(jsonURL) {
          //For now, am hardcoding url, because otherwise the repository github pages url gets prefixed. The repository github pages url works, but does not look as nice.
          const prefix = `http://www.jsongrapher.com?fromUrl=`;
          //const url = window.location.href.split('?')[0]; // gets url from browser and removes query parameters
          //const prefix = `${url}?fromUrl=`;
          // Concatenate with prefix and apply URL encoding, which is like the python urllib.parse.quote(json_string) and urllib.parse.unquote(encoded_string)
          let urlString = prefix + encodeURIComponent(jsonURL); 
          // wanted to Compress using Bzip2, but didn't succeed in importing a JS version without problems.
          //urlString = compressjs.Bzip2.compressFile(new TextEncoder().encode(urlString));
          return urlString;
      }

      function createCopyURLButton(jsonURL) {
          // Generate the URL
          const urlString = createCopyUrlLink(jsonURL);
          
          // Create the button
          const copyButton = document.createElement("button");
          copyButton.innerText = "Copy URL";
          
          // Function to copy text using a fallback method if navigator way doesn't work.
          function fallbackCopyText(text) {
              const textArea = document.createElement("textarea");
              textArea.value = text;
              document.body.appendChild(textArea);
              textArea.select();
              document.execCommand("copy");
              document.body.removeChild(textArea);
          }

          // Add click event listener to copy to clipboard
          copyButton.addEventListener("click", () => {
              if (navigator.clipboard && navigator.clipboard.writeText) {
                  navigator.clipboard.writeText(urlString).then(() => {
                      alert("URL copied to clipboard!\nNow you can paste it elsewhere!\n\n" + urlString);
                  }).catch(err => {
                      console.error("Error copying to clipboard:", err);
                  });
              } else {
                  fallbackCopyText(urlString);
                  alert("URL copied to clipboard!\nNow you can paste it elsewhere!\n\n" + urlString);
              }
          });

          return copyButton;
      }



      // A function that will create a download button for the csv file
      function createDownloadCSVButton(csv, filename) {
        // Creating a download link for the csv file
        const downloadLink = createDownloadCSVLink(csv.csv, filename);
        // Creating the button
        const downloadButton = document.createElement("button");
        // Adding text to the button
        downloadButton.innerText = "CSV";
        // Adding an event listener to the button
        downloadButton.addEventListener("click", () => {
          document.body.appendChild(downloadLink);
          downloadLink.click();
        });
        return downloadButton;
      }

      function createDownlodJSONButton(json, filename) {
        // Creating a download link for the csv file
        const downloadLink = createDownloadJSONLink(json, filename);
        // Creating the button
        const downloadButton = document.createElement("button");
        // Adding text to the button
        downloadButton.innerText = "JSON";
        // Adding an event listener to the button
        downloadButton.addEventListener("click", () => {
          document.body.appendChild(downloadLink);
          downloadLink.click();
        });
        return downloadButton;
      }

      // A function that will append a download button to the page
      // The button will be appended after the element with the id beforeElId
      function appendDownloadButtons(jsonified, filename) {
        // Parse csv from jsonified
        const csvContent = createCSV(jsonified);
        // Create download csv button
        const downloadCSVButton = createDownloadCSVButton(csvContent, filename);
        // Create Download JSON button
        const downloadJSONButton = createDownlodJSONButton(jsonified, filename);
        // Create Download URL button (technically a copy button)
        // Only show this button if someone has loaded from url.
        let downloadURLButton = null // initializing.
        if (urlReceived){  //use "if urlReceived" because it can be null or "" and this will catch both cases.
          downloadURLButton = createCopyURLButton(urlReceived);
          // Below was when I tried to put the whole JSON record into the URL, but that was quickly too long for webservers and browsers.
          //const downloadURLButton = createCopyURLButton(jsonified);
        };
        
        const buttonsContainer = document.getElementById(
          "downloadButtonsContainer"
        );
        // insert a download button with downloadLink after downloadJSON
        // Clear the container
        buttonsContainer.innerHTML =
          "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Download Last Data Set As:"; //&nbsp; is HTML code to add a space.
        // Add download JSON button
        buttonsContainer.appendChild(downloadJSONButton);
        // Add download CSV button
        buttonsContainer.appendChild(downloadCSVButton);
        // Add download URL button, but only if load from url was used.
        if (urlReceived){  //use "if urlReceived" because it can be null or "" and this will catch both cases.
          buttonsContainer.appendChild(downloadURLButton);
        }
      }

      // Convert the received dataset units to the first dataset units
      function convertUnits(jsonified, globalData) {
        return new Promise((resolve, reject) => {
          try {
            jsonified.data.forEach((dataSet) => {
              const newXUnit = getUnitFromLabel(jsonified.layout.xaxis.title.text);
              const newYUnit = getUnitFromLabel(jsonified.layout.yaxis.title.text);
              if (globalData.unit.x !== newXUnit) {
                const xConvertFactor = convert.fullConversion(
                  newXUnit,
                  globalData.unit.x
                );
                dataSet.x = dataSet.x.map((x) => {
                  if (xConvertFactor.status == 0) {
                    return parseFloat(x) * xConvertFactor.output.num;
                  } else {
                    xConvertFactor.messages.forEach((message) => {
                      errorDiv.innerText += message.message + "\n";
                    });
                  }
                });
              }

              if (globalData.unit.y !== newYUnit) {
                const yConvertFactor = convert.fullConversion(
                  newYUnit,
                  globalData.unit.y
                );
                dataSet.y = dataSet.y.map((y) => {
                  if (yConvertFactor.status == 0) {
                    return parseFloat(y) * yConvertFactor.output.num;
                  } else {
                    yConvertFactor.messages.forEach((message) => {
                      errorDiv.innerText += message.message + "\n";
                    });
                  }
                });
              }
            });
            resolve(jsonified);
          } catch (err) {
            reject(err);
          }
        });
      }

      async function initializeJSONGrapher() {
        try {
          const universalSchemas = await prepareUniversalSchemas();
          schema1json = universalSchemas[0];
          schema2json = universalSchemas[1];
          return [schema1json, schema2json];
        } catch (err) {
          console.log("Error from initializeJSONGrapher: ", err);
        }
      }

      // a function that merges jsonified with the template
      function mergeObjects(jsonified, schema_template) {
        const merged = JSON.parse(JSON.stringify(jsonified));

        merged.data.forEach((dataSet) => {
          dataSet.mode = schema_template.data[0].mode;
          dataSet.line = schema_template.data[0].mode;
        });

        return merged;
      }

      // Helper function to read file as text using Promises, so we can use await.
      async function readFileAsText(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.fileName = file.name;

          reader.addEventListener("load", () => resolve(reader.result), { once: true });
          reader.addEventListener("error", () => reject(new Error("File reading error")));

          reader.readAsText(file);
        });
      }


      async function loadFromUrlParams(urlInput){
        if (isValidUrl(urlInput)){ 
          const url = parseUrl(urlInput);
          urlReceived = url //This line is populating a global variable. 
          loadAndPlotData(url, "url");
        } else {
          console.error("No URL entered.");
          errorDiv.innerText += "Error: Please enter a valid URL.\n";
        }
      };
      ///############################ BELOW IS THE MAIN BLOCK OF CODE FOR JSON GRAPHER ##################################
      if (urlParamsString){ loadFromUrlParams(urlParamsString)};
      // STEP 0: Prepare the 'universal' schemas occurs inside initializeJSONGrapher
      initializeJSONGrapher()
        .then((resp) => {
          const toggleSection = document.getElementById("toggleSection"); //get toggle section so actions can hide it.
          const toRevealSection = document.getElementById("toReveal"); //get toReveal section so actions can reveal
          // Assign variables to the two universal schemas.
          schema = resp[0];
          plotlyTemplate = resp[1];
           // STEP 1: User selects a file from computer or drops a file on the browser
           // Checks if the browser supports the File API
           // User selects a file or drags/drops one
          if (window.FileList && window.File) {
            // Event that fires when the user selects a file from the computer from the choose file button
            const fileSelector = document.getElementById("file-selector");
            if (fileSelector) {
              fileSelector.addEventListener("change", (event) => {
                toggleSection.style.display = "none"; // "none" to hide and "block" to show. Those are built in keywords.
                toRevealSection.style.display = "block"; // "none" to hide and "block" to show. Those are built in keywords.
                loadAndPlotData(event, "change");
              });
            }
            // Event listener for drag and drop
            const dropArea = document.getElementById("file-drop-area");
            if (dropArea) {
              dropArea.addEventListener("dragover", (event) => {
                event.stopPropagation();
                event.preventDefault();
                event.dataTransfer.dropEffect = "copy";
              });

              dropArea.addEventListener("drop", (event) => {
                event.preventDefault();
                toggleSection.style.display = "none"; // "none" to hide and "block" to show. Those are built in keywords.
                toRevealSection.style.display = "block"; // "none" to hide and "block" to show. Those are built in keywords.
                loadAndPlotData(event, "drop");
              });
            }
          }

          // User inputs URL via a prompt instead of selecting/dropping a file
          const loadFromUrlButton = document.getElementById("load-from-url");
          if (loadFromUrlButton) {
            loadFromUrlButton.addEventListener("click", () => {
              const urlInput = window.prompt("Enter the URL with a desired .json File:");
              if (isValidUrl(urlInput)){ 
                const url = parseUrl(urlInput);
                urlReceived = url //This line is populating a global variable. 
                toggleSection.style.display = "none"; // "none" to hide and "block" to show. Those are built in keywords.
                toRevealSection.style.display = "block"; // "none" to hide and "block" to show. Those are built in keywords.
                loadAndPlotData(url, "url");
              } else {
                console.error("No URL entered.");
                errorDiv.innerText += "Error: Please enter a valid URL.\n";
              }
            });
          }
        })
        .catch((e) => {
          console.log(e);
          errorDiv.innerText += "Error fetching json-schema files...\n";
        });


      // This function is called when the user drops a file or uploads it via the input button or drag and drop
      async function loadAndPlotData(event, eventType) {
        let loadingMessage = "Loading and plotting data, including evaluating any equations and running any simulations.";
        errorDiv.innerText += loadingMessage; //We want to use a variable so we can remove the loading message, later.
        let fileType; //Initializing filetype.
        let jsonified; // initializing
        // Checks if the file is dropped and if it is uploaded via the input button and gets the file
        // STEP 1 (Variation A): User selects a file from computer or drops a file on the browser
        //TODO: Variation A should probably be functionalized to take event, eventType and return jsonified
        if (eventType === "change" || eventType === "drop") {
          let file;
          if (eventType === "change") {
            file = event.target.files[0];
          } else if (eventType === "drop") {
            file = event.dataTransfer.files[0];
          }
          // Initialize the reader
          const reader = new FileReader();
          reader.fileName = file.name;
          // Read file contents asynchronously
          try {
            dataLoaded = await readFileAsText(file);
          } catch (error) {
            errorDiv.innerText += `Error: Failed to read file. ${error.message} \n`;
            return;
          }
          document.getElementById("file-selector").value = ""; // resetting to blank.
          fileType = findFileType(file.name); //initialized near beginning of loadAndPlotData
          recentFileName = getFileName(file.name);//This is a global variable.
        }
        // STEP 1 (Variation B): User Providees a URL.
        //Should actually also also csv, probably.
        if (eventType === "url"){
          jsonified = await loadJsonFromUrl(event);//the event will have the url in it.
          filetype = "json";
          const toggleSection = document.getElementById("toggleSection");
          const toRevealSection = document.getElementById("toReveal"); //get toReveal section so actions can reveal
          toggleSection.style.display = "none"; // "none" to hide and "block" to show. Those are built in keywords.
          toRevealSection.style.display = "block"; // "none" to hide and "block" to show. Those are built in keywords.
        }
      
        // STEP 2 (VARIATION A): If the file is a .csv or .tsv file it is converted to a .json file
        if (eventType === "change" || eventType === "drop") {
          try {
            // try to parse the file as json
            jsonified = jsonifyData(fileType, dataLoaded);
          } catch (e) {
            errorDiv.innerText += `Error: Data record could not be converted to JSON. If it is in a zipfile, unzip before uploading. Error Details: ${e.message} \n`;
          }
        }
        // Checking if the uploaded data is valid against the schema
        // STEP 3: Check if the jsonified object is a valid JSON file against the schema
        const [schema_type, schema_template] = await getSchemaType(jsonified);

        if (Object.keys(schema_type).length === 0) {
          errorDiv.innerText +=
            "Schema check: There was no Schema specific to this DataType, or the schema was not compatible. The default scatter plot schema was used.\n";
          schema_type = schema;
        }

        // validate the json
        const validate = ajv.compile(schema_type);
        const valid = validate(jsonified);

        if (!valid) {
          // Console log an error if the data is not valid against the schema
          console.log("validate errors: ", JSON.stringify(validate.errors));
          // Display an error message if the data is not valid against the schema
          errorDiv.innerText += `Json file does not match the schema. ${JSON.stringify(
            validate.errors
          )}\n`;
          errorDiv.innerText += `Json file does not match the schema. ${JSON.stringify(
            validate.errors
          )}\n`;
        } else {
          let _jsonified = jsonified;
          if (Object.keys(schema_template).length !== 0) {
            _jsonified = mergeObjects(jsonified, schema_template);
          }
          // If the data is valid against the schema, then we can proceed to the next step
          // if necessary create download button with json
          // STEP 4 and STEP 5 is done in the prepareForPlotting function
          const res = await prepareForPlotting(_jsonified, recentFileName);
          // STEP 6: Provide file with converted units for download as JSON and CSV by buttons
          appendDownloadButtons(res.downloadData, res.fileName);
          // STEP 7: The create a plotly JSON, clean it, and render it on the browser
          plot_with_plotly(res.data);
        }
        errorDiv.innerText = errorDiv.innerText.replace(loadingMessage,"");
      }

      // This a function that plots the data on the graph
      //the input, jsonified, is the new figDict. globalData is the 'global' figDict.
      async function prepareForPlotting(jsonified, filename) {
        return new Promise(async (resolve, reject) => {
          try {
            // Checks if the Jsonified is the first file uploaded
            if (!globalData) {
              let _jsonified = JSON.parse(JSON.stringify(jsonified)); //make a local copy
              globalData = copyJson(_jsonified); //populate global figDict since this is the first record received.            
              // Get the unit from the label
              const xUnit = getUnitFromLabel(_jsonified.layout.xaxis.title.text);
              const yUnit = getUnitFromLabel(_jsonified.layout.yaxis.title.text);

              // Adding the extracted units to _jsonified
              _jsonified.unit = {
                x: xUnit,
                y: yUnit,
              };
              // STEP 4: Check if the object has a dataSet that has a simulate key in it, and runs the simulate function based on the value provided in the key model
              // Iterate through the dataset and check if there is a simulation to run for each dataset
              // On 6/4/25, a call to the function executeImplicitDataSeriesOperations was added here to evaluate equations.
              // In the longterm, the simulation logic should be moved into executeImplicitDataSeriesOperations
              _jsonified = executeImplicitDataSeriesOperations(_jsonified); //_jsonified is a figDict.
              //This loop iterates across data_series dictionary objects objects to see if any require simulation.
              //TODO: this loop's commands should be moved into executeImplicitDataSeriesOperations. There are two loops like this in index.html
              for (const dataSet of _jsonified.data) { 
                const index = _jsonified.data.indexOf(dataSet);
                const hasSimulate = checkSimulate(dataSet);
                if (hasSimulate) {
                  //Below, the "result" has named fields inside, which we will extract.
                  result = await simulateByIndexAndPopulateFigDict(_jsonified, index);
                  simulatedJsonified = result.simulatedJsonified
                  _jsonified = result._jsonified;

                }
              }
              // There is  no STEP 5 for first record, because first record provided by the user is used to define the units of GlobalData.
              //After going through all datasets for implicit dataseries updates, we set globalData equal to the updated _jsonified, since this is the first record.
              globalData = _jsonified
              //Finally, return the objects that have been prepared for plotting and downloading.
              resolve({
                data: globalData,
                downloadData: _jsonified,
                fileName: recentFileName,
              });
            } else {
              // If the Jsonified is not the first file uploaded, then we can proceed to the next step
              fieldsMatch=true; //initialize this variable as true, and set it to false if any fields that need to match do not.
              //Check if the datatype fields match. Should actually be doing the hierarchical check with the underscores.
              if (globalData.datatype !== jsonified.datatype){
                fieldsMatch=false;
                errorDiv.innerText += "The added record's datatype is different. Stopping merging. The two values are: " + String(globalData.datatype) + " " + +String(jsonified.datatype) +   "\n";
              }
              //Check if the xaxis titles are the same after removing the units area. Ideally, should check if the units are convertable.
              if (removeUnitFromLabel(globalData.layout.xaxis.title.text) !==
                  removeUnitFromLabel(jsonified.layout.xaxis.title.text)){
                fieldsMatch=false;
                errorDiv.innerText += "The added record's xaxis label text is different. Stopping merging. The two values are: " + removeUnitFromLabel(globalData.layout.xaxis.title.text) + " " +removeUnitFromLabel(jsonified.layout.xaxis.title.text) +   "\n";
              }
              //Check if the yaxis titles are the same after removing the units area. Ideally, should check if the units are convertable.
              if (removeUnitFromLabel(globalData.layout.yaxis.title.text) !==
                  removeUnitFromLabel(jsonified.layout.yaxis.title.text)){
                fieldsMatch=false;
                errorDiv.innerText += "The added record's yaxis label text is different. Stopping merging. The two values are: " + removeUnitFromLabel(globalData.layout.yaxis.title.text) + " " +removeUnitFromLabel(jsonified.layout.yaxis.title.text) +   "\n";
              }
              if(fieldsMatch)
              {
                // create a deep copy of jsonified to avoid mutating the original jsonified
                let _jsonified = JSON.parse(JSON.stringify(jsonified));
                let simulatedJsonified; //just initializing
                let convertedJsonified; //just initializing

                // STEP 4: Check if the object has a dataSet that has a simulate key in it, and runs the simulate function based on the value provided in the key model
                // Iterate through the dataset and check if there is a simulation to run for each dataset
                // On 6/4/25, a call to the function executeImplicitDataSeriesOperations was added here to evaluate equations.
                // In the longterm, the simulation logic should be moved into executeImplicitDataSeriesOperations
                _jsonified = executeImplicitDataSeriesOperations(_jsonified); //globalData is a figDict.
                //This loop iterates across data_series dictionary objects objects to see if any require simulation.
                //TODO: this loop's commands should be moved into executeImplicitDataSeriesOperations. There are two loops like this in index.html
                for (const dataSet of _jsonified.data) {
                  const index = _jsonified.data.indexOf(dataSet);
                  const hasSimulate = checkSimulate(dataSet);
                  if (hasSimulate) {
                    //Below, the "result" has named fields inside, which we will extract.
                    result = await simulateByIndexAndPopulateFigDict(_jsonified, index);
                    simulatedJsonified = result.simulatedJsonified
                    _jsonified = result._jsonified;                
                    } 
                  }
                // STEP 5: Check if the units in the _jsonified are the same as the units in the overall record and convert them if needed.
                _jsonified = await convertUnits( _jsonified, globalData);

                // merge the new data with the globalData so everything can be plotted together.
                globalData.data = [
                  ...globalData.data,
                  ..._jsonified.data,
                ];
                //Finally, return the objects that have been prepared for plotting an downloading.
                resolve({
                  data: globalData,
                  downloadData: _jsonified,
                  fileName: recentFileName,
                });
              } else {
                //clearData(); //Should not clear data when chart or axis titles do not match, just should not plot the new data.
                errorDiv.innerText += `Added data not plotted. The records were not compatible for merging. Click the button to clear data if you want to start a new graph. \n`;
              }
            }
          } catch (err) {
            reject(err);
            console.log("Error from plotData: ", err);
          }
        });
      }
    </script>
  </body>
  <footer>
    <center>
      <a href="./other_html/license.html">License</a>
      <a href="Manual.pdf" target="_blank">Manual</a>
      <a href="https://github.com/AdityaSavara/JSONGrapher" target="_blank"
        >Source</a
      >
      <a href="/other_html/credits.html">Credits</a>
    </center>
  </footer>
</html>